// zod/v4/core@3.25.63 downloaded from https://ga.jspm.io/npm:zod@3.25.63/dist/esm/v4/core/index.js

import{j as e,f as t,a as n,N as s,B as o,n as r,g as a,b as u,e as c,p as l,d as p,r as d,c as f,h as m,o as h,i as v,k as _,l as g,m as z,q as b,s as w,t as $,u as k,v as Z,w as S}from"../../../../_/B1zKr9SI.js";export{y as clone,x as util}from"../../../../_/B1zKr9SI.js";export{i as locales}from"../../../../_/DCImmIHf.js";import"../locales/ar.js";import"../locales/az.js";import"../locales/be.js";import"../locales/ca.js";import"../locales/cs.js";import"../locales/de.js";import"../locales/en.js";import"../locales/es.js";import"../locales/fa.js";import"../locales/fi.js";import"../locales/fr.js";import"../locales/fr-CA.js";import"../locales/he.js";import"../locales/hu.js";import"../locales/id.js";import"../locales/it.js";import"../locales/ja.js";import"../locales/kh.js";import"../locales/ko.js";import"../locales/mk.js";import"../locales/ms.js";import"../locales/nl.js";import"../locales/no.js";import"../locales/ota.js";import"../locales/ps.js";import"../locales/pl.js";import"../locales/pt.js";import"../locales/ru.js";import"../locales/sl.js";import"../locales/sv.js";import"../locales/ta.js";import"../locales/th.js";import"../locales/tr.js";import"../locales/ua.js";import"../locales/ur.js";import"../locales/vi.js";import"../locales/zh-CN.js";import"../locales/zh-TW.js";function T(e,t,n){function s(n,s){var o;Object.defineProperty(n,"_zod",{value:n._zod??{},enumerable:false});(o=n._zod).traits??(o.traits=new Set);n._zod.traits.add(e);t(n,s);for(const e in r.prototype)e in n||Object.defineProperty(n,e,{value:r.prototype[e].bind(n)});n._zod.constr=r;n._zod.def=s}const o=n?.Parent??Object;class Definition extends o{}Object.defineProperty(Definition,"name",{value:e});function r(e){var t;const o=n?.Parent?new Definition:this;s(o,e);(t=o._zod).deferred??(t.deferred=[]);for(const e of o._zod.deferred)e();return o}Object.defineProperty(r,"init",{value:s});Object.defineProperty(r,Symbol.hasInstance,{value:t=>!!(n?.Parent&&t instanceof n.Parent)||t?._zod?.traits?.has(e)});Object.defineProperty(r,"name",{value:e});return r}const E=Symbol("zod_brand");class $ZodAsyncError extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}const j={};function A(e){e&&Object.assign(j,e);return j}const O=(t,n)=>{t.name="$ZodError";Object.defineProperty(t,"_zod",{value:t._zod,enumerable:false});Object.defineProperty(t,"issues",{value:n,enumerable:false});Object.defineProperty(t,"message",{get(){return JSON.stringify(n,e,2)},enumerable:true})};const I=T("$ZodError",O);const N=T("$ZodError",O,{Parent:Error});function P(e,t=e=>e.message){const n={};const s=[];for(const o of e.issues)if(o.path.length>0){n[o.path[0]]=n[o.path[0]]||[];n[o.path[0]].push(t(o))}else s.push(t(o));return{formErrors:s,fieldErrors:n}}function F(e,t){const n=t||function(e){return e.message};const s={_errors:[]};const o=e=>{for(const t of e.issues)if(t.code==="invalid_union"&&t.errors.length)t.errors.map((e=>o({issues:e})));else if(t.code==="invalid_key")o({issues:t.issues});else if(t.code==="invalid_element")o({issues:t.issues});else if(t.path.length===0)s._errors.push(n(t));else{let e=s;let o=0;while(o<t.path.length){const s=t.path[o];const r=o===t.path.length-1;if(r){e[s]=e[s]||{_errors:[]};e[s]._errors.push(n(t))}else e[s]=e[s]||{_errors:[]};e=e[s];o++}}};o(e);return s}function C(e,t){const n=t||function(e){return e.message};const s={errors:[]};const o=(e,t=[])=>{var r,i;for(const a of e.issues)if(a.code==="invalid_union"&&a.errors.length)a.errors.map((e=>o({issues:e},a.path)));else if(a.code==="invalid_key")o({issues:a.issues},a.path);else if(a.code==="invalid_element")o({issues:a.issues},a.path);else{const e=[...t,...a.path];if(e.length===0){s.errors.push(n(a));continue}let o=s;let u=0;while(u<e.length){const t=e[u];const s=u===e.length-1;if(typeof t==="string"){o.properties??(o.properties={});(r=o.properties)[t]??(r[t]={errors:[]});o=o.properties[t]}else{o.items??(o.items=[]);(i=o.items)[t]??(i[t]={errors:[]});o=o.items[t]}s&&o.errors.push(n(a));u++}}};o(e);return s}function M(e){const t=[];for(const n of e)if(typeof n==="number")t.push(`[${n}]`);else if(typeof n==="symbol")t.push(`[${JSON.stringify(String(n))}]`);else if(/[^\w$]/.test(n))t.push(`[${JSON.stringify(n)}]`);else{t.length&&t.push(".");t.push(n)}return t.join("")}function R(e){const t=[];const n=[...e.issues].sort(((e,t)=>e.path.length-t.path.length));for(const e of n){t.push(`✖ ${e.message}`);e.path?.length&&t.push(`  → at ${M(e.path)}`)}return t.join("\n")}const D=e=>(n,s,o,r)=>{const i=o?Object.assign(o,{async:false}):{async:false};const a=n._zod.run({value:s,issues:[]},i);if(a instanceof Promise)throw new $ZodAsyncError;if(a.issues.length){const n=new(r?.Err??e)(a.issues.map((e=>t(e,i,A()))));Error.captureStackTrace(n,r?.callee);throw n}return a.value};const J=D(N);const V=e=>async(n,s,o,r)=>{const i=o?Object.assign(o,{async:true}):{async:true};let a=n._zod.run({value:s,issues:[]},i);a instanceof Promise&&(a=await a);if(a.issues.length){const n=new(r?.Err??e)(a.issues.map((e=>t(e,i,A()))));Error.captureStackTrace(n,r?.callee);throw n}return a.value};const U=V(N);const L=e=>(n,s,o)=>{const r=o?{...o,async:false}:{async:false};const i=n._zod.run({value:s,issues:[]},r);if(i instanceof Promise)throw new $ZodAsyncError;return i.issues.length?{success:false,error:new(e??I)(i.issues.map((e=>t(e,r,A()))))}:{success:true,data:i.value}};const B=L(N);const W=e=>async(n,s,o)=>{const r=o?Object.assign(o,{async:true}):{async:true};let i=n._zod.run({value:s,issues:[]},r);i instanceof Promise&&(i=await i);return i.issues.length?{success:false,error:new e(i.issues.map((e=>t(e,r,A()))))}:{success:true,data:i.value}};const G=W(N);const Y=/^[cC][^\s-]{8,}$/;const q=/^[0-9a-z]+$/;const K=/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;const H=/^[0-9a-vA-V]{20}$/;const X=/^[A-Za-z0-9]{27}$/;const Q=/^[a-zA-Z0-9_-]{21}$/;const ee=/^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;const te=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;const ne=/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 4122 UUID.
 *
 * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */const se=e=>e?new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`):/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;const oe=se(4);const re=se(6);const ie=se(7);const ae=/^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;const ue=/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;const ce=/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;const le=/^[^\s@"]{1,64}@[^\s@]{1,255}$/u;const pe=/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;const de="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";function fe(){return new RegExp(de,"u")}const me=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;const he=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;const ve=/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;const _e=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;const ye=/^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;const ge=/^[A-Za-z0-9_-]*$/;const ze=/^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;const be=/^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;const we=/^\+(?:[0-9]){6,14}[0-9]$/;const $e="(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";const ke=new RegExp(`^${$e}$`);function xe(e){const t="(?:[01]\\d|2[0-3]):[0-5]\\d";const n=typeof e.precision==="number"?e.precision===-1?`${t}`:e.precision===0?`${t}:[0-5]\\d`:`${t}:[0-5]\\d\\.\\d{${e.precision}}`:`${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;return n}function Ze(e){return new RegExp(`^${xe(e)}$`)}function Se(e){const t=xe({precision:e.precision});const n=["Z"];e.local&&n.push("");e.offset&&n.push("([+-]\\d{2}:\\d{2})");const s=`${t}(?:${n.join("|")})`;return new RegExp(`^${$e}T(?:${s})$`)}const Te=e=>{const t=e?`[\\s\\S]{${e?.minimum??0},${e?.maximum??""}}`:"[\\s\\S]*";return new RegExp(`^${t}$`)};const Ee=/^\d+n?$/;const je=/^\d+$/;const Ae=/^-?\d+(?:\.\d+)?/i;const Oe=/true|false/i;const Ie=/null/i;const Ne=/undefined/i;const Pe=/^[^A-Z]*$/;const Fe=/^[^a-z]*$/;var Ce=Object.freeze(Object.defineProperty({__proto__:null,_emoji:de,base64:ye,base64url:ge,bigint:Ee,boolean:Oe,browserEmail:pe,cidrv4:ve,cidrv6:_e,cuid:Y,cuid2:q,date:ke,datetime:Se,domain:be,duration:ee,e164:we,email:ae,emoji:fe,extendedDuration:te,guid:ne,hostname:ze,html5Email:ue,integer:je,ipv4:me,ipv6:he,ksuid:X,lowercase:Pe,nanoid:Q,null:Ie,number:Ae,rfc5322Email:ce,string:Te,time:Ze,ulid:K,undefined:Ne,unicodeEmail:le,uppercase:Fe,uuid:se,uuid4:oe,uuid6:re,uuid7:ie,xid:H},Symbol.toStringTag,{value:"Module"}));const Me=T("$ZodCheck",((e,t)=>{var n;e._zod??(e._zod={});e._zod.def=t;(n=e._zod).onattach??(n.onattach=[])}));const Re={number:"number",bigint:"bigint",object:"date"};const De=T("$ZodCheckLessThan",((e,t)=>{Me.init(e,t);const n=Re[typeof t.value];e._zod.onattach.push((e=>{const n=e._zod.bag;const s=(t.inclusive?n.maximum:n.exclusiveMaximum)??Number.POSITIVE_INFINITY;t.value<s&&(t.inclusive?n.maximum=t.value:n.exclusiveMaximum=t.value)}));e._zod.check=s=>{(t.inclusive?s.value<=t.value:s.value<t.value)||s.issues.push({origin:n,code:"too_big",maximum:t.value,input:s.value,inclusive:t.inclusive,inst:e,continue:!t.abort})}}));const Je=T("$ZodCheckGreaterThan",((e,t)=>{Me.init(e,t);const n=Re[typeof t.value];e._zod.onattach.push((e=>{const n=e._zod.bag;const s=(t.inclusive?n.minimum:n.exclusiveMinimum)??Number.NEGATIVE_INFINITY;t.value>s&&(t.inclusive?n.minimum=t.value:n.exclusiveMinimum=t.value)}));e._zod.check=s=>{(t.inclusive?s.value>=t.value:s.value>t.value)||s.issues.push({origin:n,code:"too_small",minimum:t.value,input:s.value,inclusive:t.inclusive,inst:e,continue:!t.abort})}}));const Ve=T("$ZodCheckMultipleOf",((e,t)=>{Me.init(e,t);e._zod.onattach.push((e=>{var n;(n=e._zod.bag).multipleOf??(n.multipleOf=t.value)}));e._zod.check=s=>{if(typeof s.value!==typeof t.value)throw new Error("Cannot mix number and bigint in multiple_of check.");const o=typeof s.value==="bigint"?s.value%t.value===BigInt(0):n(s.value,t.value)===0;o||s.issues.push({origin:typeof s.value,code:"not_multiple_of",divisor:t.value,input:s.value,inst:e,continue:!t.abort})}}));const Ue=T("$ZodCheckNumberFormat",((e,t)=>{Me.init(e,t);t.format=t.format||"float64";const n=t.format?.includes("int");const o=n?"int":"number";const[r,i]=s[t.format];e._zod.onattach.push((e=>{const s=e._zod.bag;s.format=t.format;s.minimum=r;s.maximum=i;n&&(s.pattern=je)}));e._zod.check=s=>{const a=s.value;if(n){if(!Number.isInteger(a)){s.issues.push({expected:o,format:t.format,code:"invalid_type",input:a,inst:e});return}if(!Number.isSafeInteger(a)){a>0?s.issues.push({input:a,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,continue:!t.abort}):s.issues.push({input:a,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,continue:!t.abort});return}}a<r&&s.issues.push({origin:"number",input:a,code:"too_small",minimum:r,inclusive:true,inst:e,continue:!t.abort});a>i&&s.issues.push({origin:"number",input:a,code:"too_big",maximum:i,inst:e})}}));const Le=T("$ZodCheckBigIntFormat",((e,t)=>{Me.init(e,t);const[n,s]=o[t.format];e._zod.onattach.push((e=>{const o=e._zod.bag;o.format=t.format;o.minimum=n;o.maximum=s}));e._zod.check=o=>{const r=o.value;r<n&&o.issues.push({origin:"bigint",input:r,code:"too_small",minimum:n,inclusive:true,inst:e,continue:!t.abort});r>s&&o.issues.push({origin:"bigint",input:r,code:"too_big",maximum:s,inst:e})}}));const Be=T("$ZodCheckMaxSize",((e,t)=>{Me.init(e,t);e._zod.when=e=>{const t=e.value;return!r(t)&&t.size!==void 0};e._zod.onattach.push((e=>{const n=e._zod.bag.maximum??Number.POSITIVE_INFINITY;t.maximum<n&&(e._zod.bag.maximum=t.maximum)}));e._zod.check=n=>{const s=n.value;const o=s.size;o<=t.maximum||n.issues.push({origin:a(s),code:"too_big",maximum:t.maximum,input:s,inst:e,continue:!t.abort})}}));const We=T("$ZodCheckMinSize",((e,t)=>{Me.init(e,t);e._zod.when=e=>{const t=e.value;return!r(t)&&t.size!==void 0};e._zod.onattach.push((e=>{const n=e._zod.bag.minimum??Number.NEGATIVE_INFINITY;t.minimum>n&&(e._zod.bag.minimum=t.minimum)}));e._zod.check=n=>{const s=n.value;const o=s.size;o>=t.minimum||n.issues.push({origin:a(s),code:"too_small",minimum:t.minimum,input:s,inst:e,continue:!t.abort})}}));const Ge=T("$ZodCheckSizeEquals",((e,t)=>{Me.init(e,t);e._zod.when=e=>{const t=e.value;return!r(t)&&t.size!==void 0};e._zod.onattach.push((e=>{const n=e._zod.bag;n.minimum=t.size;n.maximum=t.size;n.size=t.size}));e._zod.check=n=>{const s=n.value;const o=s.size;if(o===t.size)return;const r=o>t.size;n.issues.push({origin:a(s),...r?{code:"too_big",maximum:t.size}:{code:"too_small",minimum:t.size},input:n.value,inst:e,continue:!t.abort})}}));const Ye=T("$ZodCheckMaxLength",((e,t)=>{Me.init(e,t);e._zod.when=e=>{const t=e.value;return!r(t)&&t.length!==void 0};e._zod.onattach.push((e=>{const n=e._zod.bag.maximum??Number.POSITIVE_INFINITY;t.maximum<n&&(e._zod.bag.maximum=t.maximum)}));e._zod.check=n=>{const s=n.value;const o=s.length;if(o<=t.maximum)return;const r=u(s);n.issues.push({origin:r,code:"too_big",maximum:t.maximum,inclusive:true,input:s,inst:e,continue:!t.abort})}}));const qe=T("$ZodCheckMinLength",((e,t)=>{Me.init(e,t);e._zod.when=e=>{const t=e.value;return!r(t)&&t.length!==void 0};e._zod.onattach.push((e=>{const n=e._zod.bag.minimum??Number.NEGATIVE_INFINITY;t.minimum>n&&(e._zod.bag.minimum=t.minimum)}));e._zod.check=n=>{const s=n.value;const o=s.length;if(o>=t.minimum)return;const r=u(s);n.issues.push({origin:r,code:"too_small",minimum:t.minimum,inclusive:true,input:s,inst:e,continue:!t.abort})}}));const Ke=T("$ZodCheckLengthEquals",((e,t)=>{Me.init(e,t);e._zod.when=e=>{const t=e.value;return!r(t)&&t.length!==void 0};e._zod.onattach.push((e=>{const n=e._zod.bag;n.minimum=t.length;n.maximum=t.length;n.length=t.length}));e._zod.check=n=>{const s=n.value;const o=s.length;if(o===t.length)return;const r=u(s);const i=o>t.length;n.issues.push({origin:r,...i?{code:"too_big",maximum:t.length}:{code:"too_small",minimum:t.length},input:n.value,inst:e,continue:!t.abort})}}));const He=T("$ZodCheckStringFormat",((e,t)=>{var n;Me.init(e,t);e._zod.onattach.push((e=>{const n=e._zod.bag;n.format=t.format;if(t.pattern){n.patterns??(n.patterns=new Set);n.patterns.add(t.pattern)}}));(n=e._zod).check??(n.check=n=>{if(!t.pattern)throw new Error("Not implemented.");t.pattern.lastIndex=0;t.pattern.test(n.value)||n.issues.push({origin:"string",code:"invalid_format",format:t.format,input:n.value,...t.pattern?{pattern:t.pattern.toString()}:{},inst:e,continue:!t.abort})})}));const Xe=T("$ZodCheckRegex",((e,t)=>{He.init(e,t);e._zod.check=n=>{t.pattern.lastIndex=0;t.pattern.test(n.value)||n.issues.push({origin:"string",code:"invalid_format",format:"regex",input:n.value,pattern:t.pattern.toString(),inst:e,continue:!t.abort})}}));const Qe=T("$ZodCheckLowerCase",((e,t)=>{t.pattern??(t.pattern=Pe);He.init(e,t)}));const et=T("$ZodCheckUpperCase",((e,t)=>{t.pattern??(t.pattern=Fe);He.init(e,t)}));const tt=T("$ZodCheckIncludes",((e,t)=>{Me.init(e,t);const n=c(t.includes);const s=new RegExp(typeof t.position==="number"?`^.{${t.position}}${n}`:n);t.pattern=s;e._zod.onattach.push((e=>{const t=e._zod.bag;t.patterns??(t.patterns=new Set);t.patterns.add(s)}));e._zod.check=n=>{n.value.includes(t.includes,t.position)||n.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:t.includes,input:n.value,inst:e,continue:!t.abort})}}));const nt=T("$ZodCheckStartsWith",((e,t)=>{Me.init(e,t);const n=new RegExp(`^${c(t.prefix)}.*`);t.pattern??(t.pattern=n);e._zod.onattach.push((e=>{const t=e._zod.bag;t.patterns??(t.patterns=new Set);t.patterns.add(n)}));e._zod.check=n=>{n.value.startsWith(t.prefix)||n.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:t.prefix,input:n.value,inst:e,continue:!t.abort})}}));const st=T("$ZodCheckEndsWith",((e,t)=>{Me.init(e,t);const n=new RegExp(`.*${c(t.suffix)}$`);t.pattern??(t.pattern=n);e._zod.onattach.push((e=>{const t=e._zod.bag;t.patterns??(t.patterns=new Set);t.patterns.add(n)}));e._zod.check=n=>{n.value.endsWith(t.suffix)||n.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:t.suffix,input:n.value,inst:e,continue:!t.abort})}}));function ot(e,t,n){e.issues.length&&t.issues.push(...l(n,e.issues))}const rt=T("$ZodCheckProperty",((e,t)=>{Me.init(e,t);e._zod.check=e=>{const n=t.schema._zod.run({value:e.value[t.property],issues:[]},{});if(n instanceof Promise)return n.then((n=>ot(n,e,t.property)));ot(n,e,t.property)}}));const it=T("$ZodCheckMimeType",((e,t)=>{Me.init(e,t);const n=new Set(t.mime);e._zod.onattach.push((e=>{e._zod.bag.mime=t.mime}));e._zod.check=s=>{n.has(s.value.type)||s.issues.push({code:"invalid_value",values:t.mime,input:s.value.type,path:["type"],inst:e})}}));const at=T("$ZodCheckOverwrite",((e,t)=>{Me.init(e,t);e._zod.check=e=>{e.value=t.tx(e.value)}}));class Doc{constructor(e=[]){this.content=[];this.indent=0;this&&(this.args=e)}indented(e){this.indent+=1;e(this);this.indent-=1}write(e){if(typeof e==="function"){e(this,{execution:"sync"});e(this,{execution:"async"});return}const t=e;const n=t.split("\n").filter((e=>e));const s=Math.min(...n.map((e=>e.length-e.trimStart().length)));const o=n.map((e=>e.slice(s))).map((e=>" ".repeat(this.indent*2)+e));for(const e of o)this.content.push(e)}compile(){const e=Function;const t=this?.args;const n=this?.content??[""];const s=[...n.map((e=>`  ${e}`))];return new e(...t,s.join("\n"))}}const ut={major:4,minor:0,patch:0};const ct=T("$ZodType",((e,t)=>{var n;e??(e={});p(e._zod,"id",(()=>t.type+"_"+d(10)));e._zod.def=t;e._zod.bag=e._zod.bag||{};e._zod.version=ut;const s=[...e._zod.def.checks??[]];e._zod.traits.has("$ZodCheck")&&s.unshift(e);for(const t of s)for(const n of t._zod.onattach)n(e);if(s.length===0){(n=e._zod).deferred??(n.deferred=[]);e._zod.deferred?.push((()=>{e._zod.run=e._zod.parse}))}else{const t=(e,t,n)=>{let s=f(e);let o;for(const r of t){if(r._zod.when){const t=r._zod.when(e);if(!t)continue}else if(s)continue;const t=e.issues.length;const i=r._zod.check(e);if(i instanceof Promise&&n?.async===false)throw new $ZodAsyncError;if(o||i instanceof Promise)o=(o??Promise.resolve()).then((async()=>{await i;const n=e.issues.length;n!==t&&(s||(s=f(e,t)))}));else{const n=e.issues.length;if(n===t)continue;s||(s=f(e,t))}}return o?o.then((()=>e)):e};e._zod.run=(n,o)=>{const r=e._zod.parse(n,o);if(r instanceof Promise){if(o.async===false)throw new $ZodAsyncError;return r.then((e=>t(e,s,o)))}return t(r,s,o)}}e["~standard"]={validate:t=>{try{const n=B(e,t);return n.success?{value:n.data}:{issues:n.error?.issues}}catch(n){return G(e,t).then((e=>e.success?{value:e.data}:{issues:e.error?.issues}))}},vendor:"zod",version:1}}));const lt=T("$ZodString",((e,t)=>{ct.init(e,t);e._zod.pattern=[...e?._zod.bag?.patterns??[]].pop()??Te(e._zod.bag);e._zod.parse=(n,s)=>{if(t.coerce)try{n.value=String(n.value)}catch(s){}if(typeof n.value==="string")return n;n.issues.push({expected:"string",code:"invalid_type",input:n.value,inst:e});return n}}));const pt=T("$ZodStringFormat",((e,t)=>{He.init(e,t);lt.init(e,t)}));const dt=T("$ZodGUID",((e,t)=>{t.pattern??(t.pattern=ne);pt.init(e,t)}));const ft=T("$ZodUUID",((e,t)=>{if(t.version){const e={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8};const n=e[t.version];if(n===void 0)throw new Error(`Invalid UUID version: "${t.version}"`);t.pattern??(t.pattern=se(n))}else t.pattern??(t.pattern=se());pt.init(e,t)}));const mt=T("$ZodEmail",((e,t)=>{t.pattern??(t.pattern=ae);pt.init(e,t)}));const ht=T("$ZodURL",((e,t)=>{pt.init(e,t);e._zod.check=n=>{try{const s=new URL(n.value);if(t.hostname){t.hostname.lastIndex=0;t.hostname.test(s.hostname)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:ze.source,input:n.value,inst:e,continue:!t.abort})}if(t.protocol){t.protocol.lastIndex=0;t.protocol.test(s.protocol.endsWith(":")?s.protocol.slice(0,-1):s.protocol)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:t.protocol.source,input:n.value,inst:e,continue:!t.abort})}return}catch(s){n.issues.push({code:"invalid_format",format:"url",input:n.value,inst:e,continue:!t.abort})}}}));const vt=T("$ZodEmoji",((e,t)=>{t.pattern??(t.pattern=fe());pt.init(e,t)}));const _t=T("$ZodNanoID",((e,t)=>{t.pattern??(t.pattern=Q);pt.init(e,t)}));const yt=T("$ZodCUID",((e,t)=>{t.pattern??(t.pattern=Y);pt.init(e,t)}));const gt=T("$ZodCUID2",((e,t)=>{t.pattern??(t.pattern=q);pt.init(e,t)}));const zt=T("$ZodULID",((e,t)=>{t.pattern??(t.pattern=K);pt.init(e,t)}));const bt=T("$ZodXID",((e,t)=>{t.pattern??(t.pattern=H);pt.init(e,t)}));const wt=T("$ZodKSUID",((e,t)=>{t.pattern??(t.pattern=X);pt.init(e,t)}));const $t=T("$ZodISODateTime",((e,t)=>{t.pattern??(t.pattern=Se(t));pt.init(e,t);e._zod.check}));const kt=T("$ZodISODate",((e,t)=>{t.pattern??(t.pattern=ke);pt.init(e,t)}));const xt=T("$ZodISOTime",((e,t)=>{t.pattern??(t.pattern=Ze(t));pt.init(e,t);e._zod.check}));const Zt=T("$ZodISODuration",((e,t)=>{t.pattern??(t.pattern=ee);pt.init(e,t)}));const St=T("$ZodIPv4",((e,t)=>{t.pattern??(t.pattern=me);pt.init(e,t);e._zod.onattach.push((e=>{const t=e._zod.bag;t.format="ipv4"}))}));const Tt=T("$ZodIPv6",((e,t)=>{t.pattern??(t.pattern=he);pt.init(e,t);e._zod.onattach.push((e=>{const t=e._zod.bag;t.format="ipv6"}));e._zod.check=n=>{try{new URL(`http://[${n.value}]`)}catch{n.issues.push({code:"invalid_format",format:"ipv6",input:n.value,inst:e,continue:!t.abort})}}}));const Et=T("$ZodCIDRv4",((e,t)=>{t.pattern??(t.pattern=ve);pt.init(e,t)}));const jt=T("$ZodCIDRv6",((e,t)=>{t.pattern??(t.pattern=_e);pt.init(e,t);e._zod.check=n=>{const[s,o]=n.value.split("/");try{if(!o)throw new Error;const e=Number(o);if(`${e}`!==o)throw new Error;if(e<0||e>128)throw new Error;new URL(`http://[${s}]`)}catch{n.issues.push({code:"invalid_format",format:"cidrv6",input:n.value,inst:e,continue:!t.abort})}}}));function At(e){if(e==="")return true;if(e.length%4!==0)return false;try{atob(e);return true}catch{return false}}const Ot=T("$ZodBase64",((e,t)=>{t.pattern??(t.pattern=ye);pt.init(e,t);e._zod.onattach.push((e=>{e._zod.bag.contentEncoding="base64"}));e._zod.check=n=>{At(n.value)||n.issues.push({code:"invalid_format",format:"base64",input:n.value,inst:e,continue:!t.abort})}}));function It(e){if(!ge.test(e))return false;const t=e.replace(/[-_]/g,(e=>e==="-"?"+":"/"));const n=t.padEnd(Math.ceil(t.length/4)*4,"=");return At(n)}const Nt=T("$ZodBase64URL",((e,t)=>{t.pattern??(t.pattern=ge);pt.init(e,t);e._zod.onattach.push((e=>{e._zod.bag.contentEncoding="base64url"}));e._zod.check=n=>{It(n.value)||n.issues.push({code:"invalid_format",format:"base64url",input:n.value,inst:e,continue:!t.abort})}}));const Pt=T("$ZodE164",((e,t)=>{t.pattern??(t.pattern=we);pt.init(e,t)}));function Ft(e,t=null){try{const n=e.split(".");if(n.length!==3)return false;const[s]=n;const o=JSON.parse(atob(s));return(!("typ"in o)||o?.typ==="JWT")&&(!!o.alg&&(!t||"alg"in o&&o.alg===t))}catch{return false}}const Ct=T("$ZodJWT",((e,t)=>{pt.init(e,t);e._zod.check=n=>{Ft(n.value,t.alg)||n.issues.push({code:"invalid_format",format:"jwt",input:n.value,inst:e,continue:!t.abort})}}));const Mt=T("$ZodNumber",((e,t)=>{ct.init(e,t);e._zod.pattern=e._zod.bag.pattern??Ae;e._zod.parse=(n,s)=>{if(t.coerce)try{n.value=Number(n.value)}catch(e){}const o=n.value;if(typeof o==="number"&&!Number.isNaN(o)&&Number.isFinite(o))return n;const r=typeof o==="number"?Number.isNaN(o)?"NaN":Number.isFinite(o)?void 0:"Infinity":void 0;n.issues.push({expected:"number",code:"invalid_type",input:o,inst:e,...r?{received:r}:{}});return n}}));const Rt=T("$ZodNumber",((e,t)=>{Ue.init(e,t);Mt.init(e,t)}));const Dt=T("$ZodBoolean",((e,t)=>{ct.init(e,t);e._zod.pattern=Oe;e._zod.parse=(n,s)=>{if(t.coerce)try{n.value=Boolean(n.value)}catch(e){}const o=n.value;if(typeof o==="boolean")return n;n.issues.push({expected:"boolean",code:"invalid_type",input:o,inst:e});return n}}));const Jt=T("$ZodBigInt",((e,t)=>{ct.init(e,t);e._zod.pattern=Ee;e._zod.parse=(n,s)=>{if(t.coerce)try{n.value=BigInt(n.value)}catch(e){}const{value:o}=n;if(typeof o==="bigint")return n;n.issues.push({expected:"bigint",code:"invalid_type",input:o,inst:e});return n}}));const Vt=T("$ZodBigInt",((e,t)=>{Le.init(e,t);Jt.init(e,t)}));const Ut=T("$ZodSymbol",((e,t)=>{ct.init(e,t);e._zod.parse=(t,n)=>{const{value:s}=t;if(typeof s==="symbol")return t;t.issues.push({expected:"symbol",code:"invalid_type",input:s,inst:e});return t}}));const Lt=T("$ZodUndefined",((e,t)=>{ct.init(e,t);e._zod.pattern=Ne;e._zod.values=new Set([void 0]);e._zod.parse=(t,n)=>{const{value:s}=t;if(typeof s==="undefined")return t;t.issues.push({expected:"undefined",code:"invalid_type",input:s,inst:e});return t}}));const Bt=T("$ZodNull",((e,t)=>{ct.init(e,t);e._zod.pattern=Ie;e._zod.values=new Set([null]);e._zod.parse=(t,n)=>{const{value:s}=t;if(s===null)return t;t.issues.push({expected:"null",code:"invalid_type",input:s,inst:e});return t}}));const Wt=T("$ZodAny",((e,t)=>{ct.init(e,t);e._zod.parse=e=>e}));const Gt=T("$ZodUnknown",((e,t)=>{ct.init(e,t);e._zod.parse=e=>e}));const Yt=T("$ZodNever",((e,t)=>{ct.init(e,t);e._zod.parse=(t,n)=>{t.issues.push({expected:"never",code:"invalid_type",input:t.value,inst:e});return t}}));const qt=T("$ZodVoid",((e,t)=>{ct.init(e,t);e._zod.parse=(t,n)=>{const{value:s}=t;if(typeof s==="undefined")return t;t.issues.push({expected:"void",code:"invalid_type",input:s,inst:e});return t}}));const Kt=T("$ZodDate",((e,t)=>{ct.init(e,t);e._zod.parse=(n,s)=>{if(t.coerce)try{n.value=new Date(n.value)}catch(e){}const o=n.value;const r=o instanceof Date;const i=r&&!Number.isNaN(o.getTime());if(i)return n;n.issues.push({expected:"date",code:"invalid_type",input:o,...r?{received:"Invalid Date"}:{},inst:e});return n}}));function Ht(e,t,n){e.issues.length&&t.issues.push(...l(n,e.issues));t.value[n]=e.value}const Xt=T("$ZodArray",((e,t)=>{ct.init(e,t);e._zod.parse=(n,s)=>{const o=n.value;if(!Array.isArray(o)){n.issues.push({expected:"array",code:"invalid_type",input:o,inst:e});return n}n.value=Array(o.length);const r=[];for(let e=0;e<o.length;e++){const i=o[e];const a=t.element._zod.run({value:i,issues:[]},s);a instanceof Promise?r.push(a.then((t=>Ht(t,n,e)))):Ht(a,n,e)}return r.length?Promise.all(r).then((()=>n)):n}}));function Qt(e,t,n){e.issues.length&&t.issues.push(...l(n,e.issues));t.value[n]=e.value}function en(e,t,n,s){e.issues.length?s[n]===void 0?t.value[n]=n in s?void 0:e.value:t.issues.push(...l(n,e.issues)):e.value===void 0?n in s&&(t.value[n]=void 0):t.value[n]=e.value}const tn=T("$ZodObject",((e,t)=>{ct.init(e,t);const n=m((()=>{const e=Object.keys(t.shape);for(const n of e)if(!(t.shape[n]instanceof ct))throw new Error(`Invalid element at key "${n}": expected a Zod schema`);const n=h(t.shape);return{shape:t.shape,keys:e,keySet:new Set(e),numKeys:e.length,optionalKeys:new Set(n)}}));p(e._zod,"propValues",(()=>{const e=t.shape;const n={};for(const t in e){const s=e[t]._zod;if(s.values){n[t]??(n[t]=new Set);for(const e of s.values)n[t].add(e)}}return n}));const s=e=>{const t=new Doc(["shape","payload","ctx"]);const{keys:s,optionalKeys:o}=n.value;const r=e=>{const t=v(e);return`shape[${t}]._zod.run({ value: input[${t}], issues: [] }, ctx)`};t.write("const input = payload.value;");const i=Object.create(null);for(const e of s)i[e]=d(15);t.write("const newResult = {}");for(const e of s)if(o.has(e)){const n=i[e];t.write(`const ${n} = ${r(e)};`);const s=v(e);t.write(`\n        if (${n}.issues.length) {\n          if (input[${s}] === undefined) {\n            if (${s} in input) {\n              newResult[${s}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${n}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${s}, ...iss.path] : [${s}],\n              }))\n            );\n          }\n        } else if (${n}.value === undefined) {\n          if (${s} in input) newResult[${s}] = undefined;\n        } else {\n          newResult[${s}] = ${n}.value;\n        }\n        `)}else{const n=i[e];t.write(`const ${n} = ${r(e)};`);t.write(`\n          if (${n}.issues.length) payload.issues = payload.issues.concat(${n}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${v(e)}, ...iss.path] : [${v(e)}]\n          })));`);t.write(`newResult[${v(e)}] = ${n}.value`)}t.write("payload.value = newResult;");t.write("return payload;");const a=t.compile();return(t,n)=>a(e,t,n)};let o;const r=_;const i=!j.jitless;const a=g;const u=i&&a.value;const{catchall:c}=t;let l;e._zod.parse=(a,p)=>{l??(l=n.value);const d=a.value;if(!r(d)){a.issues.push({expected:"object",code:"invalid_type",input:d,inst:e});return a}const f=[];if(i&&u&&p?.async===false&&p.jitless!==true){o||(o=s(t.shape));a=o(a,p)}else{a.value={};const e=l.shape;for(const t of l.keys){const n=e[t];const s=n._zod.run({value:d[t],issues:[]},p);const o=n._zod.optin==="optional"&&n._zod.optout==="optional";s instanceof Promise?f.push(s.then((e=>o?en(e,a,t,d):Qt(e,a,t)))):o?en(s,a,t,d):Qt(s,a,t)}}if(!c)return f.length?Promise.all(f).then((()=>a)):a;const m=[];const h=l.keySet;const v=c._zod;const _=v.def.type;for(const e of Object.keys(d)){if(h.has(e))continue;if(_==="never"){m.push(e);continue}const t=v.run({value:d[e],issues:[]},p);t instanceof Promise?f.push(t.then((t=>Qt(t,a,e)))):Qt(t,a,e)}m.length&&a.issues.push({code:"unrecognized_keys",keys:m,input:d,inst:e});return f.length?Promise.all(f).then((()=>a)):a}}));function nn(e,n,s,o){for(const t of e)if(t.issues.length===0){n.value=t.value;return n}n.issues.push({code:"invalid_union",input:n.value,inst:s,errors:e.map((e=>e.issues.map((e=>t(e,o,A())))))});return n}const sn=T("$ZodUnion",((e,t)=>{ct.init(e,t);p(e._zod,"values",(()=>{if(t.options.every((e=>e._zod.values)))return new Set(t.options.flatMap((e=>Array.from(e._zod.values))))}));p(e._zod,"pattern",(()=>{if(t.options.every((e=>e._zod.pattern))){const e=t.options.map((e=>e._zod.pattern));return new RegExp(`^(${e.map((e=>z(e.source))).join("|")})$`)}}));e._zod.parse=(n,s)=>{let o=false;const r=[];for(const e of t.options){const t=e._zod.run({value:n.value,issues:[]},s);if(t instanceof Promise){r.push(t);o=true}else{if(t.issues.length===0)return t;r.push(t)}}return o?Promise.all(r).then((t=>nn(t,n,e,s))):nn(r,n,e,s)}}));const on=T("$ZodDiscriminatedUnion",((e,t)=>{sn.init(e,t);const n=e._zod.parse;p(e._zod,"propValues",(()=>{const e={};for(const n of t.options){const s=n._zod.propValues;if(!s||Object.keys(s).length===0)throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(n)}"`);for(const[t,n]of Object.entries(s)){e[t]||(e[t]=new Set);for(const s of n)e[t].add(s)}}return e}));const s=m((()=>{const e=t.options;const n=new Map;for(const s of e){const e=s._zod.propValues[t.discriminator];if(!e||e.size===0)throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);for(const t of e){if(n.has(t))throw new Error(`Duplicate discriminator value "${String(t)}"`);n.set(t,s)}}return n}));e._zod.parse=(o,r)=>{const i=o.value;if(!_(i)){o.issues.push({code:"invalid_type",expected:"object",input:i,inst:e});return o}const a=s.value.get(i?.[t.discriminator]);if(a)return a._zod.run(o,r);if(t.unionFallback)return n(o,r);o.issues.push({code:"invalid_union",errors:[],note:"No matching discriminator",input:i,path:[t.discriminator],inst:e});return o}}));const rn=T("$ZodIntersection",((e,t)=>{ct.init(e,t);e._zod.parse=(e,n)=>{const{value:s}=e;const o=t.left._zod.run({value:s,issues:[]},n);const r=t.right._zod.run({value:s,issues:[]},n);const i=o instanceof Promise||r instanceof Promise;return i?Promise.all([o,r]).then((([t,n])=>un(e,t,n))):un(e,o,r)}}));function an(e,t){if(e===t)return{valid:true,data:e};if(e instanceof Date&&t instanceof Date&&+e===+t)return{valid:true,data:e};if(b(e)&&b(t)){const n=Object.keys(t);const s=Object.keys(e).filter((e=>n.indexOf(e)!==-1));const o={...e,...t};for(const n of s){const s=an(e[n],t[n]);if(!s.valid)return{valid:false,mergeErrorPath:[n,...s.mergeErrorPath]};o[n]=s.data}return{valid:true,data:o}}if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return{valid:false,mergeErrorPath:[]};const n=[];for(let s=0;s<e.length;s++){const o=e[s];const r=t[s];const i=an(o,r);if(!i.valid)return{valid:false,mergeErrorPath:[s,...i.mergeErrorPath]};n.push(i.data)}return{valid:true,data:n}}return{valid:false,mergeErrorPath:[]}}function un(e,t,n){t.issues.length&&e.issues.push(...t.issues);n.issues.length&&e.issues.push(...n.issues);if(f(e))return e;const s=an(t.value,n.value);if(!s.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);e.value=s.data;return e}const cn=T("$ZodTuple",((e,t)=>{ct.init(e,t);const n=t.items;const s=n.length-[...n].reverse().findIndex((e=>e._zod.optin!=="optional"));e._zod.parse=(o,r)=>{const i=o.value;if(!Array.isArray(i)){o.issues.push({input:i,inst:e,expected:"tuple",code:"invalid_type"});return o}o.value=[];const a=[];if(!t.rest){const t=i.length>n.length;const r=i.length<s-1;if(t||r){o.issues.push({input:i,inst:e,origin:"array",...t?{code:"too_big",maximum:n.length}:{code:"too_small",minimum:n.length}});return o}}let u=-1;for(const e of n){u++;if(u>=i.length&&u>=s)continue;const t=e._zod.run({value:i[u],issues:[]},r);t instanceof Promise?a.push(t.then((e=>ln(e,o,u)))):ln(t,o,u)}if(t.rest){const e=i.slice(n.length);for(const n of e){u++;const e=t.rest._zod.run({value:n,issues:[]},r);e instanceof Promise?a.push(e.then((e=>ln(e,o,u)))):ln(e,o,u)}}return a.length?Promise.all(a).then((()=>o)):o}}));function ln(e,t,n){e.issues.length&&t.issues.push(...l(n,e.issues));t.value[n]=e.value}const pn=T("$ZodRecord",((e,n)=>{ct.init(e,n);e._zod.parse=(s,o)=>{const r=s.value;if(!b(r)){s.issues.push({expected:"record",code:"invalid_type",input:r,inst:e});return s}const i=[];if(n.keyType._zod.values){const t=n.keyType._zod.values;s.value={};for(const e of t)if(typeof e==="string"||typeof e==="number"||typeof e==="symbol"){const t=n.valueType._zod.run({value:r[e],issues:[]},o);if(t instanceof Promise)i.push(t.then((t=>{t.issues.length&&s.issues.push(...l(e,t.issues));s.value[e]=t.value})));else{t.issues.length&&s.issues.push(...l(e,t.issues));s.value[e]=t.value}}let a;for(const e in r)if(!t.has(e)){a=a??[];a.push(e)}a&&a.length>0&&s.issues.push({code:"unrecognized_keys",input:r,inst:e,keys:a})}else{s.value={};for(const a of Reflect.ownKeys(r)){if(a==="__proto__")continue;const u=n.keyType._zod.run({value:a,issues:[]},o);if(u instanceof Promise)throw new Error("Async schemas not supported in object keys currently");if(u.issues.length){s.issues.push({origin:"record",code:"invalid_key",issues:u.issues.map((e=>t(e,o,A()))),input:a,path:[a],inst:e});s.value[u.value]=u.value;continue}const c=n.valueType._zod.run({value:r[a],issues:[]},o);if(c instanceof Promise)i.push(c.then((e=>{e.issues.length&&s.issues.push(...l(a,e.issues));s.value[u.value]=e.value})));else{c.issues.length&&s.issues.push(...l(a,c.issues));s.value[u.value]=c.value}}}return i.length?Promise.all(i).then((()=>s)):s}}));const dn=T("$ZodMap",((e,t)=>{ct.init(e,t);e._zod.parse=(n,s)=>{const o=n.value;if(!(o instanceof Map)){n.issues.push({expected:"map",code:"invalid_type",input:o,inst:e});return n}const r=[];n.value=new Map;for(const[i,a]of o){const u=t.keyType._zod.run({value:i,issues:[]},s);const c=t.valueType._zod.run({value:a,issues:[]},s);u instanceof Promise||c instanceof Promise?r.push(Promise.all([u,c]).then((([t,r])=>{fn(t,r,n,i,o,e,s)}))):fn(u,c,n,i,o,e,s)}return r.length?Promise.all(r).then((()=>n)):n}}));function fn(e,n,s,o,r,i,a){e.issues.length&&(w.has(typeof o)?s.issues.push(...l(o,e.issues)):s.issues.push({origin:"map",code:"invalid_key",input:r,inst:i,issues:e.issues.map((e=>t(e,a,A())))}));n.issues.length&&(w.has(typeof o)?s.issues.push(...l(o,n.issues)):s.issues.push({origin:"map",code:"invalid_element",input:r,inst:i,key:o,issues:n.issues.map((e=>t(e,a,A())))}));s.value.set(e.value,n.value)}const mn=T("$ZodSet",((e,t)=>{ct.init(e,t);e._zod.parse=(n,s)=>{const o=n.value;if(!(o instanceof Set)){n.issues.push({input:o,inst:e,expected:"set",code:"invalid_type"});return n}const r=[];n.value=new Set;for(const e of o){const o=t.valueType._zod.run({value:e,issues:[]},s);o instanceof Promise?r.push(o.then((e=>hn(e,n)))):hn(o,n)}return r.length?Promise.all(r).then((()=>n)):n}}));function hn(e,t){e.issues.length&&t.issues.push(...e.issues);t.value.add(e.value)}const vn=T("$ZodEnum",((e,t)=>{ct.init(e,t);const n=$(t.entries);e._zod.values=new Set(n);e._zod.pattern=new RegExp(`^(${n.filter((e=>w.has(typeof e))).map((e=>typeof e==="string"?c(e):e.toString())).join("|")})$`);e._zod.parse=(t,s)=>{const o=t.value;if(e._zod.values.has(o))return t;t.issues.push({code:"invalid_value",values:n,input:o,inst:e});return t}}));const _n=T("$ZodLiteral",((e,t)=>{ct.init(e,t);e._zod.values=new Set(t.values);e._zod.pattern=new RegExp(`^(${t.values.map((e=>typeof e==="string"?c(e):e?e.toString():String(e))).join("|")})$`);e._zod.parse=(n,s)=>{const o=n.value;if(e._zod.values.has(o))return n;n.issues.push({code:"invalid_value",values:t.values,input:o,inst:e});return n}}));const yn=T("$ZodFile",((e,t)=>{ct.init(e,t);e._zod.parse=(t,n)=>{const s=t.value;if(s instanceof File)return t;t.issues.push({expected:"file",code:"invalid_type",input:s,inst:e});return t}}));const gn=T("$ZodTransform",((e,t)=>{ct.init(e,t);e._zod.parse=(e,n)=>{const s=t.transform(e.value,e);if(n.async){const t=s instanceof Promise?s:Promise.resolve(s);return t.then((t=>{e.value=t;return e}))}if(s instanceof Promise)throw new $ZodAsyncError;e.value=s;return e}}));const zn=T("$ZodOptional",((e,t)=>{ct.init(e,t);e._zod.optin="optional";e._zod.optout="optional";p(e._zod,"values",(()=>t.innerType._zod.values?new Set([...t.innerType._zod.values,void 0]):void 0));p(e._zod,"pattern",(()=>{const e=t.innerType._zod.pattern;return e?new RegExp(`^(${z(e.source)})?$`):void 0}));e._zod.parse=(e,n)=>e.value===void 0?e:t.innerType._zod.run(e,n)}));const bn=T("$ZodNullable",((e,t)=>{ct.init(e,t);p(e._zod,"optin",(()=>t.innerType._zod.optin));p(e._zod,"optout",(()=>t.innerType._zod.optout));p(e._zod,"pattern",(()=>{const e=t.innerType._zod.pattern;return e?new RegExp(`^(${z(e.source)}|null)$`):void 0}));p(e._zod,"values",(()=>t.innerType._zod.values?new Set([...t.innerType._zod.values,null]):void 0));e._zod.parse=(e,n)=>e.value===null?e:t.innerType._zod.run(e,n)}));const wn=T("$ZodDefault",((e,t)=>{ct.init(e,t);e._zod.optin="optional";p(e._zod,"values",(()=>t.innerType._zod.values));e._zod.parse=(e,n)=>{if(e.value===void 0){e.value=t.defaultValue;return e}const s=t.innerType._zod.run(e,n);return s instanceof Promise?s.then((e=>$n(e,t))):$n(s,t)}}));function $n(e,t){e.value===void 0&&(e.value=t.defaultValue);return e}const kn=T("$ZodPrefault",((e,t)=>{ct.init(e,t);e._zod.optin="optional";p(e._zod,"values",(()=>t.innerType._zod.values));e._zod.parse=(e,n)=>{e.value===void 0&&(e.value=t.defaultValue);return t.innerType._zod.run(e,n)}}));const xn=T("$ZodNonOptional",((e,t)=>{ct.init(e,t);p(e._zod,"values",(()=>{const e=t.innerType._zod.values;return e?new Set([...e].filter((e=>e!==void 0))):void 0}));e._zod.parse=(n,s)=>{const o=t.innerType._zod.run(n,s);return o instanceof Promise?o.then((t=>Zn(t,e))):Zn(o,e)}}));function Zn(e,t){e.issues.length||e.value!==void 0||e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:t});return e}const Sn=T("$ZodSuccess",((e,t)=>{ct.init(e,t);e._zod.parse=(e,n)=>{const s=t.innerType._zod.run(e,n);if(s instanceof Promise)return s.then((t=>{e.value=t.issues.length===0;return e}));e.value=s.issues.length===0;return e}}));const Tn=T("$ZodCatch",((e,n)=>{ct.init(e,n);p(e._zod,"optin",(()=>n.innerType._zod.optin));p(e._zod,"optout",(()=>n.innerType._zod.optout));p(e._zod,"values",(()=>n.innerType._zod.values));e._zod.parse=(e,s)=>{const o=n.innerType._zod.run(e,s);if(o instanceof Promise)return o.then((o=>{e.value=o.value;if(o.issues.length){e.value=n.catchValue({...e,error:{issues:o.issues.map((e=>t(e,s,A())))},input:e.value});e.issues=[]}return e}));e.value=o.value;if(o.issues.length){e.value=n.catchValue({...e,error:{issues:o.issues.map((e=>t(e,s,A())))},input:e.value});e.issues=[]}return e}}));const En=T("$ZodNaN",((e,t)=>{ct.init(e,t);e._zod.parse=(t,n)=>{if(typeof t.value!=="number"||!Number.isNaN(t.value)){t.issues.push({input:t.value,inst:e,expected:"nan",code:"invalid_type"});return t}return t}}));const jn=T("$ZodPipe",((e,t)=>{ct.init(e,t);p(e._zod,"values",(()=>t.in._zod.values));p(e._zod,"optin",(()=>t.in._zod.optin));p(e._zod,"optout",(()=>t.out._zod.optout));e._zod.parse=(e,n)=>{const s=t.in._zod.run(e,n);return s instanceof Promise?s.then((e=>An(e,t,n))):An(s,t,n)}}));function An(e,t,n){return f(e)?e:t.out._zod.run({value:e.value,issues:e.issues},n)}const On=T("$ZodReadonly",((e,t)=>{ct.init(e,t);p(e._zod,"propValues",(()=>t.innerType._zod.propValues));p(e._zod,"optin",(()=>t.innerType._zod.optin));p(e._zod,"optout",(()=>t.innerType._zod.optout));e._zod.parse=(e,n)=>{const s=t.innerType._zod.run(e,n);return s instanceof Promise?s.then(In):In(s)}}));function In(e){e.value=Object.freeze(e.value);return e}const Nn=T("$ZodTemplateLiteral",((e,t)=>{ct.init(e,t);const n=[];for(const e of t.parts)if(e instanceof ct){if(!e._zod.pattern)throw new Error(`Invalid template literal part, no pattern found: ${[...e._zod.traits].shift()}`);const t=e._zod.pattern instanceof RegExp?e._zod.pattern.source:e._zod.pattern;if(!t)throw new Error(`Invalid template literal part: ${e._zod.traits}`);const s=t.startsWith("^")?1:0;const o=t.endsWith("$")?t.length-1:t.length;n.push(t.slice(s,o))}else{if(e!==null&&!k.has(typeof e))throw new Error(`Invalid template literal part: ${e}`);n.push(c(`${e}`))}e._zod.pattern=new RegExp(`^${n.join("")}$`);e._zod.parse=(t,n)=>{if(typeof t.value!=="string"){t.issues.push({input:t.value,inst:e,expected:"template_literal",code:"invalid_type"});return t}e._zod.pattern.lastIndex=0;if(!e._zod.pattern.test(t.value)){t.issues.push({input:t.value,inst:e,code:"invalid_format",format:"template_literal",pattern:e._zod.pattern.source});return t}return t}}));const Pn=T("$ZodPromise",((e,t)=>{ct.init(e,t);e._zod.parse=(e,n)=>Promise.resolve(e.value).then((e=>t.innerType._zod.run({value:e,issues:[]},n)))}));const Fn=T("$ZodLazy",((e,t)=>{ct.init(e,t);p(e._zod,"innerType",(()=>t.getter()));p(e._zod,"pattern",(()=>e._zod.innerType._zod.pattern));p(e._zod,"propValues",(()=>e._zod.innerType._zod.propValues));p(e._zod,"optin",(()=>e._zod.innerType._zod.optin));p(e._zod,"optout",(()=>e._zod.innerType._zod.optout));e._zod.parse=(t,n)=>{const s=e._zod.innerType;return s._zod.run(t,n)}}));const Cn=T("$ZodCustom",((e,t)=>{Me.init(e,t);ct.init(e,t);e._zod.parse=(e,t)=>e;e._zod.check=n=>{const s=n.value;const o=t.fn(s);if(o instanceof Promise)return o.then((t=>Mn(t,n,s,e)));Mn(o,n,s,e)}}));function Mn(e,t,n,s){if(!e){const e={code:"custom",input:n,inst:s,path:[...s._zod.def.path??[]],continue:!s._zod.def.abort};s._zod.def.params&&(e.params=s._zod.def.params);t.issues.push(Z(e))}}const Rn=Symbol("ZodOutput");const Dn=Symbol("ZodInput");class $ZodRegistry{constructor(){this._map=new WeakMap;this._idmap=new Map}add(e,...t){const n=t[0];this._map.set(e,n);if(n&&typeof n==="object"&&"id"in n){if(this._idmap.has(n.id))throw new Error(`ID ${n.id} already exists in the registry`);this._idmap.set(n.id,e)}return this}remove(e){this._map.delete(e);return this}get(e){const t=e._zod.parent;if(t){const n={...this.get(t)??{}};delete n.id;return{...n,...this._map.get(e)}}return this._map.get(e)}has(e){return this._map.has(e)}}function Jn(){return new $ZodRegistry}const Vn=Jn();function Un(e,t){return new e({type:"string",...S(t)})}function Ln(e,t){return new e({type:"string",coerce:true,...S(t)})}function Bn(e,t){return new e({type:"string",format:"email",check:"string_format",abort:false,...S(t)})}function Wn(e,t){return new e({type:"string",format:"guid",check:"string_format",abort:false,...S(t)})}function Gn(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,...S(t)})}function Yn(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,version:"v4",...S(t)})}function qn(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,version:"v6",...S(t)})}function Kn(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,version:"v7",...S(t)})}function Hn(e,t){return new e({type:"string",format:"url",check:"string_format",abort:false,...S(t)})}function Xn(e,t){return new e({type:"string",format:"emoji",check:"string_format",abort:false,...S(t)})}function Qn(e,t){return new e({type:"string",format:"nanoid",check:"string_format",abort:false,...S(t)})}function es(e,t){return new e({type:"string",format:"cuid",check:"string_format",abort:false,...S(t)})}function ts(e,t){return new e({type:"string",format:"cuid2",check:"string_format",abort:false,...S(t)})}function ns(e,t){return new e({type:"string",format:"ulid",check:"string_format",abort:false,...S(t)})}function ss(e,t){return new e({type:"string",format:"xid",check:"string_format",abort:false,...S(t)})}function os(e,t){return new e({type:"string",format:"ksuid",check:"string_format",abort:false,...S(t)})}function rs(e,t){return new e({type:"string",format:"ipv4",check:"string_format",abort:false,...S(t)})}function is(e,t){return new e({type:"string",format:"ipv6",check:"string_format",abort:false,...S(t)})}function as(e,t){return new e({type:"string",format:"cidrv4",check:"string_format",abort:false,...S(t)})}function us(e,t){return new e({type:"string",format:"cidrv6",check:"string_format",abort:false,...S(t)})}function cs(e,t){return new e({type:"string",format:"base64",check:"string_format",abort:false,...S(t)})}function ls(e,t){return new e({type:"string",format:"base64url",check:"string_format",abort:false,...S(t)})}function ps(e,t){return new e({type:"string",format:"e164",check:"string_format",abort:false,...S(t)})}function ds(e,t){return new e({type:"string",format:"jwt",check:"string_format",abort:false,...S(t)})}const fs={Any:null,Minute:-1,Second:0,Millisecond:3,Microsecond:6};function ms(e,t){return new e({type:"string",format:"datetime",check:"string_format",offset:false,local:false,precision:null,...S(t)})}function hs(e,t){return new e({type:"string",format:"date",check:"string_format",...S(t)})}function vs(e,t){return new e({type:"string",format:"time",check:"string_format",precision:null,...S(t)})}function _s(e,t){return new e({type:"string",format:"duration",check:"string_format",...S(t)})}function ys(e,t){return new e({type:"number",checks:[],...S(t)})}function gs(e,t){return new e({type:"number",coerce:true,checks:[],...S(t)})}function zs(e,t){return new e({type:"number",check:"number_format",abort:false,format:"safeint",...S(t)})}function bs(e,t){return new e({type:"number",check:"number_format",abort:false,format:"float32",...S(t)})}function ws(e,t){return new e({type:"number",check:"number_format",abort:false,format:"float64",...S(t)})}function $s(e,t){return new e({type:"number",check:"number_format",abort:false,format:"int32",...S(t)})}function ks(e,t){return new e({type:"number",check:"number_format",abort:false,format:"uint32",...S(t)})}function xs(e,t){return new e({type:"boolean",...S(t)})}function Zs(e,t){return new e({type:"boolean",coerce:true,...S(t)})}function Ss(e,t){return new e({type:"bigint",...S(t)})}function Ts(e,t){return new e({type:"bigint",coerce:true,...S(t)})}function Es(e,t){return new e({type:"bigint",check:"bigint_format",abort:false,format:"int64",...S(t)})}function js(e,t){return new e({type:"bigint",check:"bigint_format",abort:false,format:"uint64",...S(t)})}function As(e,t){return new e({type:"symbol",...S(t)})}function Os(e,t){return new e({type:"undefined",...S(t)})}function Is(e,t){return new e({type:"null",...S(t)})}function Ns(e){return new e({type:"any"})}function Ps(e){return new e({type:"unknown"})}function Fs(e,t){return new e({type:"never",...S(t)})}function Cs(e,t){return new e({type:"void",...S(t)})}function Ms(e,t){return new e({type:"date",...S(t)})}function Rs(e,t){return new e({type:"date",coerce:true,...S(t)})}function Ds(e,t){return new e({type:"nan",...S(t)})}function Js(e,t){return new De({check:"less_than",...S(t),value:e,inclusive:false})}function Vs(e,t){return new De({check:"less_than",...S(t),value:e,inclusive:true})}function Us(e,t){return new Je({check:"greater_than",...S(t),value:e,inclusive:false})}function Ls(e,t){return new Je({check:"greater_than",...S(t),value:e,inclusive:true})}function Bs(e){return Us(0,e)}function Ws(e){return Js(0,e)}function Gs(e){return Vs(0,e)}function Ys(e){return Ls(0,e)}function qs(e,t){return new Ve({check:"multiple_of",...S(t),value:e})}function Ks(e,t){return new Be({check:"max_size",...S(t),maximum:e})}function Hs(e,t){return new We({check:"min_size",...S(t),minimum:e})}function Xs(e,t){return new Ge({check:"size_equals",...S(t),size:e})}function Qs(e,t){const n=new Ye({check:"max_length",...S(t),maximum:e});return n}function eo(e,t){return new qe({check:"min_length",...S(t),minimum:e})}function to(e,t){return new Ke({check:"length_equals",...S(t),length:e})}function no(e,t){return new Xe({check:"string_format",format:"regex",...S(t),pattern:e})}function so(e){return new Qe({check:"string_format",format:"lowercase",...S(e)})}function oo(e){return new et({check:"string_format",format:"uppercase",...S(e)})}function ro(e,t){return new tt({check:"string_format",format:"includes",...S(t),includes:e})}function io(e,t){return new nt({check:"string_format",format:"starts_with",...S(t),prefix:e})}function ao(e,t){return new st({check:"string_format",format:"ends_with",...S(t),suffix:e})}function uo(e,t,n){return new rt({check:"property",property:e,schema:t,...S(n)})}function co(e,t){return new it({check:"mime_type",mime:e,...S(t)})}function lo(e){return new at({check:"overwrite",tx:e})}function po(e){return lo((t=>t.normalize(e)))}function fo(){return lo((e=>e.trim()))}function mo(){return lo((e=>e.toLowerCase()))}function ho(){return lo((e=>e.toUpperCase()))}function vo(e,t,n){return new e({type:"array",element:t,...S(n)})}function _o(e,t,n){return new e({type:"union",options:t,...S(n)})}function yo(e,t,n,s){return new e({type:"union",options:n,discriminator:t,...S(s)})}function go(e,t,n){return new e({type:"intersection",left:t,right:n})}function zo(e,t,n,s){const o=n instanceof ct;const r=o?s:n;const i=o?n:null;return new e({type:"tuple",items:t,rest:i,...S(r)})}function bo(e,t,n,s){return new e({type:"record",keyType:t,valueType:n,...S(s)})}function wo(e,t,n,s){return new e({type:"map",keyType:t,valueType:n,...S(s)})}function $o(e,t,n){return new e({type:"set",valueType:t,...S(n)})}function ko(e,t,n){const s=Array.isArray(t)?Object.fromEntries(t.map((e=>[e,e]))):t;return new e({type:"enum",entries:s,...S(n)})}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */function xo(e,t,n){return new e({type:"enum",entries:t,...S(n)})}function Zo(e,t,n){return new e({type:"literal",values:Array.isArray(t)?t:[t],...S(n)})}function So(e,t){return new e({type:"file",...S(t)})}function To(e,t){return new e({type:"transform",transform:t})}function Eo(e,t){return new e({type:"optional",innerType:t})}function jo(e,t){return new e({type:"nullable",innerType:t})}function Ao(e,t,n){return new e({type:"default",innerType:t,get defaultValue(){return typeof n==="function"?n():n}})}function Oo(e,t,n){return new e({type:"nonoptional",innerType:t,...S(n)})}function Io(e,t){return new e({type:"success",innerType:t})}function No(e,t,n){return new e({type:"catch",innerType:t,catchValue:typeof n==="function"?n:()=>n})}function Po(e,t,n){return new e({type:"pipe",in:t,out:n})}function Fo(e,t){return new e({type:"readonly",innerType:t})}function Co(e,t,n){return new e({type:"template_literal",parts:t,...S(n)})}function Mo(e,t){return new e({type:"lazy",getter:t})}function Ro(e,t){return new e({type:"promise",innerType:t})}function Do(e,t,n){const s=S(n);s.abort??(s.abort=true);const o=new e({type:"custom",check:"custom",fn:t,...s});return o}function Jo(e,t,n){const s=new e({type:"custom",check:"custom",fn:t,...S(n)});return s}function Vo(e,t){const{case:n,error:s,truthy:o,falsy:r}=S(t);let i=o??["true","1","yes","on","y","enabled"];let a=r??["false","0","no","off","n","disabled"];if(n!=="sensitive"){i=i.map((e=>typeof e==="string"?e.toLowerCase():e));a=a.map((e=>typeof e==="string"?e.toLowerCase():e))}const u=new Set(i);const c=new Set(a);const l=e.Pipe??jn;const p=e.Boolean??Dt;const d=e.String??lt;const f=e.Transform??gn;const m=new f({type:"transform",transform:(e,t)=>{let s=e;n!=="sensitive"&&(s=s.toLowerCase());if(u.has(s))return true;if(c.has(s))return false;t.issues.push({code:"invalid_value",expected:"stringbool",values:[...u,...c],input:t.value,inst:m});return{}},error:s});const h=new l({type:"pipe",in:new d({type:"string",error:s}),out:m,error:s});const v=new l({type:"pipe",in:h,out:new p({type:"boolean",error:s}),error:s});return v}class $ZodFunction{constructor(e){this._def=e;this.def=e}implement(e){if(typeof e!=="function")throw new Error("implement() must be called with a function");const t=(...n)=>{const s=this._def.input?J(this._def.input,n,void 0,{callee:t}):n;if(!Array.isArray(s))throw new Error("Invalid arguments schema: not an array or tuple schema.");const o=e(...s);return this._def.output?J(this._def.output,o,void 0,{callee:t}):o};return t}implementAsync(e){if(typeof e!=="function")throw new Error("implement() must be called with a function");const t=async(...n)=>{const s=this._def.input?await U(this._def.input,n,void 0,{callee:t}):n;if(!Array.isArray(s))throw new Error("Invalid arguments schema: not an array or tuple schema.");const o=await e(...s);return this._def.output?U(this._def.output,o,void 0,{callee:t}):o};return t}input(...e){const t=this.constructor;return Array.isArray(e[0])?new t({type:"function",input:new cn({type:"tuple",items:e[0],rest:e[1]}),output:this._def.output}):new t({type:"function",input:e[0],output:this._def.output})}output(e){const t=this.constructor;return new t({type:"function",input:this._def.input,output:e})}}function Uo(e){return new $ZodFunction({type:"function",input:Array.isArray(e?.input)?zo(cn,e?.input):e?.input??vo(Xt,Ps(Gt)),output:e?.output??Ps(Gt)})}class JSONSchemaGenerator{constructor(e){this.counter=0;this.metadataRegistry=e?.metadata??Vn;this.target=e?.target??"draft-2020-12";this.unrepresentable=e?.unrepresentable??"throw";this.override=e?.override??(()=>{});this.io=e?.io??"output";this.seen=new Map}process(e,t={path:[],schemaPath:[]}){var n;const s=e._zod.def;const o={guid:"uuid",url:"uri",datetime:"date-time",json_string:"json-string",regex:""};const r=this.seen.get(e);if(r){r.count++;const n=t.schemaPath.includes(e);n&&(r.cycle=t.path);return r.schema}const i={schema:{},count:1,cycle:void 0};this.seen.set(e,i);const a=e._zod.toJSONSchema?.();if(a)i.schema=a;else{const n={...t,schemaPath:[...t.schemaPath,e],path:t.path};const r=e._zod.parent;if(r){i.ref=r;this.process(r,n);this.seen.get(r).isParent=true}else{const t=i.schema;switch(s.type){case"string":{const n=t;n.type="string";const{minimum:s,maximum:r,format:a,patterns:u,contentEncoding:c}=e._zod.bag;typeof s==="number"&&(n.minLength=s);typeof r==="number"&&(n.maxLength=r);if(a){n.format=o[a]??a;n.format===""&&delete n.format}c&&(n.contentEncoding=c);if(u&&u.size>0){const e=[...u];e.length===1?n.pattern=e[0].source:e.length>1&&(i.schema.allOf=[...e.map((e=>({...this.target==="draft-7"?{type:"string"}:{},pattern:e.source})))])}break}case"number":{const n=t;const{minimum:s,maximum:o,format:r,multipleOf:i,exclusiveMaximum:a,exclusiveMinimum:u}=e._zod.bag;typeof r==="string"&&r.includes("int")?n.type="integer":n.type="number";typeof u==="number"&&(n.exclusiveMinimum=u);if(typeof s==="number"){n.minimum=s;typeof u==="number"&&(u>=s?delete n.minimum:delete n.exclusiveMinimum)}typeof a==="number"&&(n.exclusiveMaximum=a);if(typeof o==="number"){n.maximum=o;typeof a==="number"&&(a<=o?delete n.maximum:delete n.exclusiveMaximum)}typeof i==="number"&&(n.multipleOf=i);break}case"boolean":{const e=t;e.type="boolean";break}case"bigint":if(this.unrepresentable==="throw")throw new Error("BigInt cannot be represented in JSON Schema");break;case"symbol":if(this.unrepresentable==="throw")throw new Error("Symbols cannot be represented in JSON Schema");break;case"undefined":{const e=t;e.type="null";break}case"null":t.type="null";break;case"any":break;case"unknown":break;case"never":t.not={};break;case"void":if(this.unrepresentable==="throw")throw new Error("Void cannot be represented in JSON Schema");break;case"date":if(this.unrepresentable==="throw")throw new Error("Date cannot be represented in JSON Schema");break;case"array":{const o=t;const{minimum:r,maximum:i}=e._zod.bag;typeof r==="number"&&(o.minItems=r);typeof i==="number"&&(o.maxItems=i);o.type="array";o.items=this.process(s.element,{...n,path:[...n.path,"items"]});break}case"object":{const e=t;e.type="object";e.properties={};const o=s.shape;for(const t in o)e.properties[t]=this.process(o[t],{...n,path:[...n.path,"properties",t]});const r=new Set(Object.keys(o));const i=new Set([...r].filter((e=>{const t=s.shape[e]._zod;return this.io==="input"?t.optin===void 0:t.optout===void 0})));i.size>0&&(e.required=Array.from(i));s.catchall?._zod.def.type==="never"?e.additionalProperties=false:s.catchall?s.catchall&&(e.additionalProperties=this.process(s.catchall,{...n,path:[...n.path,"additionalProperties"]})):this.io==="output"&&(e.additionalProperties=false);break}case"union":{const e=t;e.anyOf=s.options.map(((e,t)=>this.process(e,{...n,path:[...n.path,"anyOf",t]})));break}case"intersection":{const e=t;const o=this.process(s.left,{...n,path:[...n.path,"allOf",0]});const r=this.process(s.right,{...n,path:[...n.path,"allOf",1]});const i=e=>"allOf"in e&&Object.keys(e).length===1;const a=[...i(o)?o.allOf:[o],...i(r)?r.allOf:[r]];e.allOf=a;break}case"tuple":{const o=t;o.type="array";const r=s.items.map(((e,t)=>this.process(e,{...n,path:[...n.path,"prefixItems",t]})));this.target==="draft-2020-12"?o.prefixItems=r:o.items=r;if(s.rest){const e=this.process(s.rest,{...n,path:[...n.path,"items"]});this.target==="draft-2020-12"?o.items=e:o.additionalItems=e}s.rest&&(o.items=this.process(s.rest,{...n,path:[...n.path,"items"]}));const{minimum:i,maximum:a}=e._zod.bag;typeof i==="number"&&(o.minItems=i);typeof a==="number"&&(o.maxItems=a);break}case"record":{const e=t;e.type="object";e.propertyNames=this.process(s.keyType,{...n,path:[...n.path,"propertyNames"]});e.additionalProperties=this.process(s.valueType,{...n,path:[...n.path,"additionalProperties"]});break}case"map":if(this.unrepresentable==="throw")throw new Error("Map cannot be represented in JSON Schema");break;case"set":if(this.unrepresentable==="throw")throw new Error("Set cannot be represented in JSON Schema");break;case"enum":{const e=t;const n=$(s.entries);n.every((e=>typeof e==="number"))&&(e.type="number");n.every((e=>typeof e==="string"))&&(e.type="string");e.enum=n;break}case"literal":{const e=t;const n=[];for(const e of s.values)if(e===void 0){if(this.unrepresentable==="throw")throw new Error("Literal `undefined` cannot be represented in JSON Schema")}else if(typeof e==="bigint"){if(this.unrepresentable==="throw")throw new Error("BigInt literals cannot be represented in JSON Schema");n.push(Number(e))}else n.push(e);if(n.length===0);else if(n.length===1){const t=n[0];e.type=t===null?"null":typeof t;e.const=t}else{n.every((e=>typeof e==="number"))&&(e.type="number");n.every((e=>typeof e==="string"))&&(e.type="string");n.every((e=>typeof e==="boolean"))&&(e.type="string");n.every((e=>e===null))&&(e.type="null");e.enum=n}break}case"file":{const n=t;const s={type:"string",format:"binary",contentEncoding:"binary"};const{minimum:o,maximum:r,mime:i}=e._zod.bag;o!==void 0&&(s.minLength=o);r!==void 0&&(s.maxLength=r);if(i)if(i.length===1){s.contentMediaType=i[0];Object.assign(n,s)}else n.anyOf=i.map((e=>{const t={...s,contentMediaType:e};return t}));else Object.assign(n,s);break}case"transform":if(this.unrepresentable==="throw")throw new Error("Transforms cannot be represented in JSON Schema");break;case"nullable":{const e=this.process(s.innerType,n);t.anyOf=[e,{type:"null"}];break}case"nonoptional":this.process(s.innerType,n);i.ref=s.innerType;break;case"success":{const e=t;e.type="boolean";break}case"default":this.process(s.innerType,n);i.ref=s.innerType;t.default=JSON.parse(JSON.stringify(s.defaultValue));break;case"prefault":this.process(s.innerType,n);i.ref=s.innerType;this.io==="input"&&(t._prefault=JSON.parse(JSON.stringify(s.defaultValue)));break;case"catch":{this.process(s.innerType,n);i.ref=s.innerType;let e;try{e=s.catchValue(void 0)}catch{throw new Error("Dynamic catch values are not supported in JSON Schema")}t.default=e;break}case"nan":if(this.unrepresentable==="throw")throw new Error("NaN cannot be represented in JSON Schema");break;case"template_literal":{const n=t;const s=e._zod.pattern;if(!s)throw new Error("Pattern not found in template literal");n.type="string";n.pattern=s.source;break}case"pipe":{const e=this.io==="input"?s.in._zod.def.type==="transform"?s.out:s.in:s.out;this.process(e,n);i.ref=e;break}case"readonly":this.process(s.innerType,n);i.ref=s.innerType;t.readOnly=true;break;case"promise":this.process(s.innerType,n);i.ref=s.innerType;break;case"optional":this.process(s.innerType,n);i.ref=s.innerType;break;case"lazy":{const t=e._zod.innerType;this.process(t,n);i.ref=t;break}case"custom":if(this.unrepresentable==="throw")throw new Error("Custom types cannot be represented in JSON Schema");break;default:s}}}const u=this.metadataRegistry.get(e);u&&Object.assign(i.schema,u);if(this.io==="input"&&Bo(e)){delete i.schema.examples;delete i.schema.default}this.io==="input"&&i.schema._prefault&&((n=i.schema).default??(n.default=i.schema._prefault));delete i.schema._prefault;const c=this.seen.get(e);return c.schema}emit(e,t){const n={cycles:t?.cycles??"ref",reused:t?.reused??"inline",external:t?.external??void 0};const s=this.seen.get(e);if(!s)throw new Error("Unprocessed schema. This is a bug in Zod.");const o=e=>{const t=this.target==="draft-2020-12"?"$defs":"definitions";if(n.external){const s=n.external.registry.get(e[0])?.id;if(s)return{ref:n.external.uri(s)};const o=e[1].defId??e[1].schema.id??"schema"+this.counter++;e[1].defId=o;return{defId:o,ref:`${n.external.uri("__shared")}#/${t}/${o}`}}if(e[1]===s)return{ref:"#"};const o="#";const r=`${o}/${t}/`;const i=e[1].schema.id??"__schema"+this.counter++;return{defId:i,ref:r+i}};const r=e=>{if(e[1].schema.$ref)return;const t=e[1];const{ref:n,defId:s}=o(e);t.def={...t.schema};s&&(t.defId=s);const r=t.schema;for(const e in r)delete r[e];r.$ref=n};for(const t of this.seen.entries()){const s=t[1];if(e===t[0]){r(t);continue}if(n.external){const s=n.external.registry.get(t[0])?.id;if(e!==t[0]&&s){r(t);continue}}const o=this.metadataRegistry.get(t[0])?.id;if(o)r(t);else if(s.cycle){if(n.cycles==="throw")throw new Error(`Cycle detected: #/${s.cycle?.join("/")}/<root>\n\nSet the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);n.cycles==="ref"&&r(t)}else s.count>1&&n.reused==="ref"&&r(t)}const i=(e,t)=>{const n=this.seen.get(e);const s=n.def??n.schema;const o={...s};if(n.ref===null)return;const r=n.ref;n.ref=null;if(r){i(r,t);const e=this.seen.get(r).schema;if(e.$ref&&t.target==="draft-7"){s.allOf=s.allOf??[];s.allOf.push(e)}else{Object.assign(s,e);Object.assign(s,o)}}n.isParent||this.override({zodSchema:e,jsonSchema:s})};for(const e of[...this.seen.entries()].reverse())i(e[0],{target:this.target});const a={};this.target==="draft-2020-12"?a.$schema="https://json-schema.org/draft/2020-12/schema":this.target==="draft-7"?a.$schema="http://json-schema.org/draft-07/schema#":console.warn(`Invalid target: ${this.target}`);Object.assign(a,s.def);const u=n.external?.defs??{};for(const e of this.seen.entries()){const t=e[1];t.def&&t.defId&&(u[t.defId]=t.def)}!n.external&&Object.keys(u).length>0&&(this.target==="draft-2020-12"?a.$defs=u:a.definitions=u);try{return JSON.parse(JSON.stringify(a))}catch(e){throw new Error("Error converting schema to JSON.")}}}function Lo(e,t){if(e instanceof $ZodRegistry){const n=new JSONSchemaGenerator(t);const s={};for(const t of e._idmap.entries()){const[e,s]=t;n.process(s)}const o={};const r={registry:e,uri:t?.uri||(e=>e),defs:s};for(const s of e._idmap.entries()){const[e,i]=s;o[e]=n.emit(i,{...t,external:r})}if(Object.keys(s).length>0){const e=n.target==="draft-2020-12"?"$defs":"definitions";o.__shared={[e]:s}}return{schemas:o}}const n=new JSONSchemaGenerator(t);n.process(e);return n.emit(e,t)}function Bo(e,t){const n=t??{seen:new Set};if(n.seen.has(e))return false;n.seen.add(e);const s=e;const o=s._zod.def;switch(o.type){case"string":case"number":case"bigint":case"boolean":case"date":case"symbol":case"undefined":case"null":case"any":case"unknown":case"never":case"void":case"literal":case"enum":case"nan":case"file":case"template_literal":return false;case"array":return Bo(o.element,n);case"object":for(const e in o.shape)if(Bo(o.shape[e],n))return true;return false;case"union":for(const e of o.options)if(Bo(e,n))return true;return false;case"intersection":return Bo(o.left,n)||Bo(o.right,n);case"tuple":for(const e of o.items)if(Bo(e,n))return true;return!(!o.rest||!Bo(o.rest,n));case"record":return Bo(o.keyType,n)||Bo(o.valueType,n);case"map":return Bo(o.keyType,n)||Bo(o.valueType,n);case"set":return Bo(o.valueType,n);case"promise":case"optional":case"nonoptional":case"nullable":case"readonly":return Bo(o.innerType,n);case"lazy":return Bo(o.getter(),n);case"default":return Bo(o.innerType,n);case"prefault":return Bo(o.innerType,n);case"custom":return false;case"transform":return true;case"pipe":return Bo(o.in,n)||Bo(o.out,n);case"success":return false;case"catch":return false;default:o}throw new Error(`Unknown schema type: ${o.type}`)}var Wo=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));export{Wt as $ZodAny,Xt as $ZodArray,$ZodAsyncError,Ot as $ZodBase64,Nt as $ZodBase64URL,Jt as $ZodBigInt,Vt as $ZodBigIntFormat,Dt as $ZodBoolean,Et as $ZodCIDRv4,jt as $ZodCIDRv6,yt as $ZodCUID,gt as $ZodCUID2,Tn as $ZodCatch,Me as $ZodCheck,Le as $ZodCheckBigIntFormat,st as $ZodCheckEndsWith,Je as $ZodCheckGreaterThan,tt as $ZodCheckIncludes,Ke as $ZodCheckLengthEquals,De as $ZodCheckLessThan,Qe as $ZodCheckLowerCase,Ye as $ZodCheckMaxLength,Be as $ZodCheckMaxSize,it as $ZodCheckMimeType,qe as $ZodCheckMinLength,We as $ZodCheckMinSize,Ve as $ZodCheckMultipleOf,Ue as $ZodCheckNumberFormat,at as $ZodCheckOverwrite,rt as $ZodCheckProperty,Xe as $ZodCheckRegex,Ge as $ZodCheckSizeEquals,nt as $ZodCheckStartsWith,He as $ZodCheckStringFormat,et as $ZodCheckUpperCase,Cn as $ZodCustom,Kt as $ZodDate,wn as $ZodDefault,on as $ZodDiscriminatedUnion,Pt as $ZodE164,mt as $ZodEmail,vt as $ZodEmoji,vn as $ZodEnum,I as $ZodError,yn as $ZodFile,$ZodFunction,dt as $ZodGUID,St as $ZodIPv4,Tt as $ZodIPv6,kt as $ZodISODate,$t as $ZodISODateTime,Zt as $ZodISODuration,xt as $ZodISOTime,rn as $ZodIntersection,Ct as $ZodJWT,wt as $ZodKSUID,Fn as $ZodLazy,_n as $ZodLiteral,dn as $ZodMap,En as $ZodNaN,_t as $ZodNanoID,Yt as $ZodNever,xn as $ZodNonOptional,Bt as $ZodNull,bn as $ZodNullable,Mt as $ZodNumber,Rt as $ZodNumberFormat,tn as $ZodObject,zn as $ZodOptional,jn as $ZodPipe,kn as $ZodPrefault,Pn as $ZodPromise,On as $ZodReadonly,N as $ZodRealError,pn as $ZodRecord,$ZodRegistry,mn as $ZodSet,lt as $ZodString,pt as $ZodStringFormat,Sn as $ZodSuccess,Ut as $ZodSymbol,Nn as $ZodTemplateLiteral,gn as $ZodTransform,cn as $ZodTuple,ct as $ZodType,zt as $ZodULID,ht as $ZodURL,ft as $ZodUUID,Lt as $ZodUndefined,sn as $ZodUnion,Gt as $ZodUnknown,qt as $ZodVoid,bt as $ZodXID,E as $brand,T as $constructor,Dn as $input,Rn as $output,Doc,Wo as JSONSchema,JSONSchemaGenerator,fs as TimePrecision,Ns as _any,vo as _array,cs as _base64,ls as _base64url,Ss as _bigint,xs as _boolean,No as _catch,as as _cidrv4,us as _cidrv6,Ts as _coercedBigint,Zs as _coercedBoolean,Rs as _coercedDate,gs as _coercedNumber,Ln as _coercedString,es as _cuid,ts as _cuid2,Do as _custom,Ms as _date,Ao as _default,yo as _discriminatedUnion,ps as _e164,Bn as _email,Xn as _emoji,ao as _endsWith,ko as _enum,So as _file,bs as _float32,ws as _float64,Us as _gt,Ls as _gte,Wn as _guid,ro as _includes,zs as _int,$s as _int32,Es as _int64,go as _intersection,rs as _ipv4,is as _ipv6,hs as _isoDate,ms as _isoDateTime,_s as _isoDuration,vs as _isoTime,ds as _jwt,os as _ksuid,Mo as _lazy,to as _length,Zo as _literal,so as _lowercase,Js as _lt,Vs as _lte,wo as _map,Vs as _max,Qs as _maxLength,Ks as _maxSize,co as _mime,Ls as _min,eo as _minLength,Hs as _minSize,qs as _multipleOf,Ds as _nan,Qn as _nanoid,xo as _nativeEnum,Ws as _negative,Fs as _never,Ys as _nonnegative,Oo as _nonoptional,Gs as _nonpositive,po as _normalize,Is as _null,jo as _nullable,ys as _number,Eo as _optional,lo as _overwrite,D as _parse,V as _parseAsync,Po as _pipe,Bs as _positive,Ro as _promise,uo as _property,Fo as _readonly,bo as _record,Jo as _refine,no as _regex,L as _safeParse,W as _safeParseAsync,$o as _set,Xs as _size,io as _startsWith,Un as _string,Vo as _stringbool,Io as _success,As as _symbol,Co as _templateLiteral,mo as _toLowerCase,ho as _toUpperCase,To as _transform,fo as _trim,zo as _tuple,ks as _uint32,js as _uint64,ns as _ulid,Os as _undefined,_o as _union,Ps as _unknown,oo as _uppercase,Hn as _url,Gn as _uuid,Yn as _uuidv4,qn as _uuidv6,Kn as _uuidv7,Cs as _void,ss as _xid,A as config,P as flattenError,F as formatError,Uo as function,j as globalConfig,Vn as globalRegistry,At as isValidBase64,It as isValidBase64URL,Ft as isValidJWT,J as parse,U as parseAsync,R as prettifyError,Ce as regexes,Jn as registry,B as safeParse,G as safeParseAsync,M as toDotPath,Lo as toJSONSchema,C as treeifyError,ut as version};

